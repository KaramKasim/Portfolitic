{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "307202fd",
   "metadata": {},
   "source": [
    "# Manufacturing Process Optimization (Defects from PVT)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "02d337ef",
   "metadata": {},
   "source": [
    "This script has been tested using real-time manufacturing sensor data of pressure, vibrations and temperatures to optimize defects. Load using the necessary files and metrics to use."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "35717512",
   "metadata": {},
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "from scipy import stats\n",
    "from scipy.stats import pearsonr\n",
    "from datetime import datetime, timedelta\n",
    "\n",
    "# Load data from CSV files\n",
    "production_data = pd.read_csv(\"path_to/production_data.csv\")\n",
    "sensor_data = pd.read_csv(\"path_to/sensor_data.csv\")\n",
    "shipping_data = pd.read_csv(\"path_to/shipping_data.csv\")\n",
    "quality_control_data = pd.read_csv(\"path_to/quality_control_data.csv\")\n",
    "maintenance_data = pd.read_csv(\"path_to/maintenance_data.csv\")\n",
    "raw_material_data = pd.read_csv(\"path_to/raw_material_data.csv\")\n",
    "\n",
    "# Merge data sets\n",
    "production_sensor_data = production_data.merge(sensor_data, on=\"production_run_id\", how=\"left\")\n",
    "production_sensor_shipping_data = production_sensor_data.merge(shipping_data, on=\"production_run_id\", how=\"left\")\n",
    "all_data = production_sensor_shipping_data.merge(quality_control_data, on=\"production_run_id\", how=\"left\")\n",
    "all_data = all_data.merge(maintenance_data, on=[\"production_run_id\", \"machine_id\"], how=\"left\")\n",
    "all_data = all_data.merge(raw_material_data, on=[\"material_id\"], how=\"left\")\n",
    "\n",
    "# Remove rows with missing values\n",
    "all_data = all_data.dropna()\n",
    "\n",
    "# Parse time strings\n",
    "all_data[\"activity_start_time\"] = [datetime.strptime(time_str, \"%H:%M:%S\") for time_str in all_data[\"activity_start_time\"]]\n",
    "all_data[\"activity_end_time\"] = [datetime.strptime(time_str, \"%H:%M:%S\") for time_str in all_data[\"activity_end_time\"]]\n",
    "\n",
    "# Calculate durations\n",
    "all_data[\"activity_duration_minutes\"] = (all_data[\"activity_end_time\"] - all_data[\"activity_start_time\"]).apply(lambda x: x / timedelta(minutes=1))\n",
    "all_data[\"downtime_minutes\"] = all_data.groupby(\"production_run_id\")[\"activity_duration_minutes\"].sum()\n",
    "total_downtime = all_data[\"downtime_minutes\"].sum()\n",
    "\n",
    "# Calculate performance metrics\n",
    "all_data[\"defect_rate\"] = all_data[\"num_units_defective\"] / all_data[\"num_units_produced\"]\n",
    "total_production_time = all_data[\"production_time_minutes\"].sum()\n",
    "total_operational_time = total_production_time - total_downtime\n",
    "all_data[\"uptime_perc\"] = total_operational_time / total_production_time\n",
    "all_data[\"uptime_ratio\"] = all_data[\"machine_temp\"].count() / all_data[\"num_units_produced\"]\n",
    "\n",
    "# Plot correlations\n",
    "sns.pairplot(all_data, vars=[\"machine_temp\", \"machine_pressure\", \"machine_vibration\"], hue=\"defect_rate\")\n",
    "sns.pairplot(all_data, vars=[\"machine_temp\", \"machine_pressure\", \"machine_vibration\"], hue=\"uptime_perc\")\n",
    "sns.pairplot(all_data, vars=[\"machine_temp\", \"machine_pressure\", \"machine_vibration\"], hue=\"uptime_ratio\")\n",
    "\n",
    "# Test for correlations\n",
    "defect_rate_temp_corr, defect_rate_temp_pval = stats.pearsonr(all_data[\"machine_temp\"], all_data[\"defect_rate\"])\n",
    "uptime_temp_corr, uptime_temp_pval = stats.pearsonr(all_data[\"machine_temp\"], all_data[\"uptime_ratio\"])\n",
    "defect_rate_pressure_corr, defect_rate_pressure_pval = stats.pearsonr(all_data[\"machine_pressure\"], all_data[\"defect_rate\"])\n",
    "uptime_pressure_corr, uptime_pressure_pval = stats.pearsonr(all_data[\"machine_pressure\"], all_data[\"uptime_ratio\"])\n",
    "defect_rate_vibration_corr, defect_rate_vibration_pval = stats.pearsonr(all_data[\"machine_vibration\"], all_data[\"defect_rate\"])\n",
    "uptime_vibration_corr, uptime_vibration_pval = stats.pearsonr(all_data[\"machine_vibration\"], all_data[\"uptime_ratio\"])\n",
    "\n",
    "# Add correlation and p-value results as columns in all_data\n",
    "all_data[\"defect_rate_temp_corr\"] = defect_rate_temp_corr\n",
    "all_data[\"defect_rate_temp_pval\"] = defect_rate_temp_pval\n",
    "all_data[\"uptime_temp_corr\"] = uptime_temp_corr\n",
    "all_data[\"uptime_temp_pval\"] = uptime_temp_pval\n",
    "all_data[\"defect_rate_pressure_corr\"] = defect_rate_pressure_corr\n",
    "all_data[\"defect_rate_pressure_pval\"] = defect_rate_pressure_pval\n",
    "\n",
    "# Optimizer Block for maximum uptime\n",
    "optimal_params = {}\n",
    "for machine_id in all_data[\"machine_id\"].unique():\n",
    "    machine_data = all_data[all_data[\"machine_id\"] == machine_id]\n",
    "    optimal_params[machine_id] = {}\n",
    "    for material_id in machine_data[\"material_id\"].unique():\n",
    "        material_data = machine_data[machine_data[\"material_id\"] == material_id]\n",
    "        optimal_temp = material_data[material_data[\"uptime_perc\"] == material_data[\"uptime_perc\"].max()][\"machine_temp\"].mean()\n",
    "        optimal_pressure = material_data[material_data[\"uptime_perc\"] == material_data[\"uptime_perc\"].max()][\"machine_pressure\"].mean()\n",
    "        optimal_vibration = material_data[material_data[\"uptime_perc\"] == material_data[\"uptime_perc\"].max()][\"machine_vibration\"].mean()\n",
    "        optimal_params[machine_id][material_id] = {\n",
    "            \"temp\": optimal_temp,\n",
    "            \"pressure\": optimal_pressure,\n",
    "            \"vibration\": optimal_vibration,\n",
    "        }\n",
    "\n",
    "# Convert optimal_params dictionary to a DataFrame\n",
    "optimal_params_df = pd.DataFrame.from_dict(optimal_params, orient=\"index\")\n",
    "optimal_params_df.index.name = \"machine_id\"\n",
    "optimal_params_pivoted = optimal_params_df.unstack(level=0)\n",
    "optimal_params_pivoted = optimal_params_pivoted.reset_index()\n",
    "optimal_params_pivoted = optimal_params_pivoted.set_index(\"machine_id\")\n",
    "optimal_params_pivoted = optimal_params_pivoted.reset_index()\n",
    "optimal_params_pivoted = optimal_params_pivoted.rename(columns={'level_0': 'material_id'})\n",
    "\n",
    "def split_optimal_params(row):\n",
    "    if pd.isna(row[0]):\n",
    "        return pd.Series({'temp': np.nan, 'pressure': np.nan, 'vibration': np.nan})\n",
    "    else:\n",
    "        temp = row[0]['temp']\n",
    "        pressure = row[0]['pressure']\n",
    "        vibration = row[0]['vibration']\n",
    "        return pd.Series({'temp': temp, 'pressure': pressure, 'vibration': vibration})\n",
    "\n",
    "optimal_params_pivoted[[\"temp\", \"pressure\", \"vibration\"]] = optimal_params_pivoted.apply(split_optimal_params, axis=1)\n",
    "optimal_params = optimal_params_pivoted.drop(columns=[0])\n",
    "\n",
    "# Write the production plan to a spreadsheet\n",
    "optimal_params.to_csv(\"path_to/optimal_uptime_production_plan.csv\", index=False)\n",
    "all_data.to_csv(\"path_to/all_data_prod_sens_ship_quali.csv\", index=False)\n",
    "\n",
    "# Optimizer Block for minimum defect rates\n",
    "optimal_params = {}\n",
    "for machine_id in all_data[\"machine_id\"].unique():\n",
    "    machine_data = all_data[all_data[\"machine_id\"] == machine_id]\n",
    "    optimal_params[machine_id] = {}\n",
    "    for material_id in machine_data[\"material_id\"].unique():\n",
    "        material_data = machine_data[machine_data[\"material_id\"] == material_id]\n",
    "        optimal_temp = material_data[material_data[\"defect_rate\"] == material_data[\"defect_rate\"].min()][\"machine_temp\"].mean()\n",
    "        optimal_pressure = material_data[material_data[\"defect_rate\"] == material_data[\"defect_rate\"].min()][\"machine_pressure\"].mean()\n",
    "        optimal_vibration = material_data[material_data[\"defect_rate\"] == material_data[\"defect_rate\"].min()][\"machine_vibration\"].mean()\n",
    "        optimal_params[machine_id][material_id] = {\n",
    "            \"temp\": optimal_temp,\n",
    "            \"pressure\": optimal_pressure,\n",
    "            \"vibration\": optimal_vibration,\n",
    "        }\n",
    "\n",
    "# Convert optimal_params dictionary to a DataFrame\n",
    "optimal_params_df = pd.DataFrame.from_dict(optimal_params, orient=\"index\")\n",
    "optimal_params_df.index.name = \"machine_id\"\n",
    "optimal_params_pivoted = optimal_params_df.unstack(level=0)\n",
    "optimal_params_pivoted = optimal_params_pivoted.reset_index()\n",
    "optimal_params_pivoted = optimal_params_pivoted.set_index(\"machine_id\")\n",
    "optimal_params_pivoted = optimal_params_pivoted.reset_index()\n",
    "optimal_params_pivoted = optimal_params_pivoted.rename(columns={'level_0': 'material_id'})\n",
    "\n",
    "def split_optimal_params(row):\n",
    "    if pd.isna(row[0]):\n",
    "        return pd.Series({'temp': np.nan, 'pressure': np.nan, 'vibration': np.nan})\n",
    "    else:\n",
    "        temp = row[0]['temp']\n",
    "        pressure = row[0]['pressure']\n",
    "        vibration = row[0]['vibration']\n",
    "        return pd.Series({'temp': temp, 'pressure': pressure, 'vibration': vibration})\n",
    "\n",
    "optimal_params_pivoted[[\"temp\", \"pressure\", \"vibration\"]] = optimal_params_pivoted.apply(split_optimal_params, axis=1)\n",
    "optimal_params = optimal_params_pivoted.drop(columns=[0])\n",
    "\n",
    "average_defects = all_data.groupby([\"machine_id\", \"material_id\"]).mean()[\"defect_rate\"].rename(\"defect_rate_before\").reset_index()\n",
    "target_defects = all_data.groupby([\"machine_id\", \"material_id\"]).min()[\"defect_rate\"].rename(\"optimal_defect_rate\").reset_index()\n",
    "all_data = all_data.merge(average_defects, on=[\"machine_id\", \"material_id\"])\n",
    "all_data = all_data.merge(target_defects, on=[\"machine_id\", \"material_id\"])\n",
    "optimal_params = optimal_params.merge(average_defects, on=[\"machine_id\", \"material_id\"])\n",
    "optimal_params = optimal_params.merge(target_defects, on=[\"machine_id\", \"material_id\"])\n",
    "optimal_params['Target Performance Improvement %'] = ((optimal_params['defect_rate_before'] - optimal_params['optimal_defect_rate']) / optimal_params['defect_rate_before']) * 100\n",
    "\n",
    "# Write the production plan to a spreadsheet\n",
    "optimal_params.to_csv(\"path_to/optimal_production_plan.csv\", index=False)\n",
    "all_data.to_csv(\"path_to/all_data_incl_maint_mat.csv\", index=False)\n",
    "\n",
    "# Analyze production run efficiency\n",
    "all_data[\"machine_capacity\"] = all_data[\"num_units_produced\"] / all_data[\"production_time_minutes\"]\n",
    "all_data[\"yield\"] = all_data[\"num_units_produced\"] / all_data[\"raw_material_units_used\"]\n",
    "all_data[\"output_rate\"] = all_data[\"num_units_produced\"] / all_data[\"production_time_minutes\"]\n",
    "all_data[\"efficiency\"] = all_data[\"output_rate\"] / all_data[\"machine_capacity\"]\n",
    "\n",
    "# Plot correlations between performance metrics and other variables\n",
    "all_data.plot(x=\"machine_temp\", y=\"yield\", kind=\"scatter\")\n",
    "all_data.plot(x=\"machine_pressure\", y=\"yield\", kind=\"scatter\")\n",
    "all_data.plot(x=\"machine_vibration\", y=\"yield\", kind=\"scatter\")\n",
    "all_data.plot(x=\"maintenance_type\", y=\"yield\", kind=\"bar\")\n",
    "all_data.plot(x=\"material_name\", y=\"yield\", kind=\"bar\")\n",
    "\n",
    "# Calculate correlation between machine temperature and yield\n",
    "x = all_data[\"machine_temp\"]\n",
    "y = all_data[\"yield\"]\n",
    "corr, pval = pearsonr(x, y)\n",
    "\n",
    "# Analyze the impact of machine downtime\n",
    "all_data[\"activity_start_time\"] = [datetime.strptime(time_str, \"%I:%M:%S %p\") for time_str in all_data[\"activity_start_time\"]]\n",
    "all_data[\"activity_end_time\"] = [datetime.strptime(time_str, \"%I:%M:%S %p\") for time_str in all_data[\"activity_end_time\"]]\n",
    "all_data[\"activity_duration_minutes\"] = (all_data[\"activity_end_time\"] - all_data[\"activity_start_time\"]).apply(lambda x: x / timedelta(minutes=1))\n",
    "all_data[\"downtime_minutes\"] = all_data.groupby(\"production_run_id\")[\"activity_duration_minutes\"].sum()\n",
    "all_data[\"downtime_percent\"] = all_data[\"downtime_minutes\"] / all_data[\"production_time_minutes\"]\n",
    "\n",
    "# Plot correlations between machine downtime and performance metrics\n",
    "all_data.plot(x=\"downtime_percent\", y=\"yield\", kind=\"scatter\")\n",
    "all_data.plot(x=\"downtime_percent\", y=\"output_rate\", kind=\"scatter\")\n",
    "all_data.plot(x=\"downtime_percent\", y=\"efficiency\", kind=\"scatter\")\n",
    "\n",
    "# Calculate correlation between machine downtime and yield\n",
    "x = all_data[\"downtime_percent\"]\n",
    "y = all_data[\"yield\"]\n",
    "corr, pval = pearsonr(x, y)\n",
    "\n",
    "# Analyze the impact of raw material quality\n",
    "all_data.plot(x=\"Strength\", y=\"defect_rate\", kind=\"scatter\")\n",
    "all_data.plot(x=\"Conductivity\", y=\"defect_rate\", kind=\"scatter\")\n",
    "\n",
    "# Analyze the impact of production schedule on performance\n",
    "all_data.plot(x=\"production_time_minutes\", y=\"defect_rate\", kind=\"scatter\")\n",
    "all_data.plot(x=\"production_time_minutes\", y=\"uptime\", kind=\"scatter\")\n",
    "all_data.plot(x=\"production_time_minutes\", y=\"efficiency\", kind=\"scatter\")\n",
    "\n",
    "# Calculate Pearson's correlation coefficient and p-value for each correlation\n",
    "defect_rate_schedule_corr, defect_rate_schedule_pval = stats.pearsonr(all_data[\"production_time_minutes\"], all_data[\"defect_rate\"])\n",
    "uptime_schedule_corr, uptime_schedule_pval = stats.pearsonr(all_data[\"production_time_minutes\"], all_data[\"uptime\"])\n",
    "efficiency_schedule_corr, efficiency_schedule_pval = stats.pearsonr(all_data[\"production_time_minutes\"], all_data[\"efficiency\"])\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
